#'Generate two-dimensional coordinate files of each strand for clustering
#'
#' @param in_bamfile A indexed BAM file, and the index files (.bai) must be in the same directory of the indexed BAM
#' @param in_nSBfile A indexed soft-clipped BAM file, generated and indexed by samtools script
#' @param out_dir The directory where directories of two strands are created and the output files are stored
#' @param chr_info A data.table that contains the chrinfo, can be generated by ExtractChrinfo()
#' @param RCn The cut-off value that decides the minimum weight of output when processing the in_bamfile (default 3)
#'
#' @return NULL. writes output to file, SA files are generated from in_nSBfile and RC files are from in_bamfile.
#' @export
#'
#' @import data.table
#' @rawNamespace import(IRanges, except = c(which, shift))
#' @importFrom GenomicAlignments readGAlignments
#'
#' @examples
#' WriteEndlist("input/test.sorted.bam", "input/3S_test.sorted.bam", "output/", ExtractChrinfo("input/test.sorted.bam"))
#' WriteEndlist("input/3S_test.sorted.bam", "input/3S_test.sorted.bam", "output/", ExtractChrinfo("input/3S_test.sorted.bam"))
WriteEndlist <- function(in_bamfile, in_nSBfile, out_dir, chr_info, RCn = 3){
  # start, need a method to check the dir


  # check and create two directories to save the output
  if (!dir.exists(out_dir)){
    warning(out_dir, " does not exist")
    return(message("ERROR: check the dir"))
  }
  if (dir.exists(paste0(out_dir, "positive_strand/"))){
    warning(paste0(out_dir, "positive_strand/"), " already exists")
    return(message("ERROR: check the dir."))
  }
  if (dir.exists(paste0(out_dir, "negative_strand/"))){
    warning(paste0(out_dir, "negative_strand/"), " already exists")
    return(message("ERROR: check the dir."))
  }
  dir.create(paste0(out_dir, "positive_strand/"))
  dir.create(paste0(out_dir, "negative_strand/"))
  cb_list <- list()


  # loop to write SAfile and RCfile in both strand for every chr
  for (chrno in as.character(chr_info[, chr])) {

    # load seq info of the chr and convert it into data.table
    print(paste0(chrno," is loading"))
    which <- GenomicRanges::GRanges(seqnames = chrno, ranges = IRanges::IRanges(1, chr_info[chr == chrno, V1] ))
    paramsx<- Rsamtools::ScanBamParam(tag = c("UB","CB"),which = which)
    paramsy<- Rsamtools::ScanBamParam(tag = c("UB","CB"),what = "seq",which = which)
    x <- GenomicAlignments::readGAlignments(in_bamfile, param = paramsx)  # x, info of the origin bam file
    y <- GenomicAlignments::readGAlignments(in_nSBfile, param = paramsy)  # y, info of the soft-clipped bam file
    aln_all <- data.table(Chr = as.character(seqnames(x)),
                          strand = as.character(strand(x)),
                          start = start(x),
                          end = end(x),
                          cigar = as.character(cigar(x)),
                          UB = mcols(x)[, 1],
                          CB = mcols(x)[, 2])
    aln_ns <- data.table(Chr = as.character(seqnames(y)),
                         strand = as.character(strand(y)),
                         start = start(y),
                         end = end(y),
                         cigar = as.character(cigar(y)),
                         UB = mcols(y)[, 2],
                         CB = mcols(y)[, 3],
                         seq = as.character(mcols(y)[, 1]))

    # key index
    setkey(aln_all, Chr, start)
    setorder(aln_all, Chr, start)
    setkey(aln_ns, Chr, start)
    setorder(aln_ns, Chr, start)

    # check seq length
    if(length(unique(qwidth(x))) != 1){
      warning(paste0("Inconsistent length in ", chrno))
    }
    seqlength <- qwidth(x)[1]

    # clean
    rm(x)
    rm(y)
    gc()

    # deduplicate and rm na
    aln_all <- aln_all[complete.cases(UB, CB), ]
    aln_all[strand == "+" , uni := length(unique(end)), by = .(UB,CB)]
    aln_all[strand == "-" , uni := length(unique(start)), by = .(UB,CB)]
    aln_all <- aln_all[uni == 1]
    aln_all <- aln_all[!duplicated(aln_all[,.(UB,CB)]),]
    aln_ns <- aln_ns[complete.cases(UB, CB, seq), ]
    aln_ns[strand == "+" , uni := length(unique(end)), by = .(UB,CB)]
    aln_ns[strand == "-" , uni := length(unique(start)), by = .(UB,CB)]
    aln_ns <- aln_ns[uni == 1]
    aln_ns <- aln_ns[!duplicated(aln_ns[,.(UB,CB)]),]
    print("start computing")

    # extract CBlist of the chr
    if(nrow(aln_all) != 0 ){
      cb_list[[chrno]] <- aln_all[, .(unique(CB))]
    }

    # negative strand
    if (nrow(aln_all[(strand == "-"), ]) != 0) {
      # extract negative strand RCfile of the chr
      aln_pb_n <- aln_all[(strand == "-"), .(start)]
      fwrite(aln_pb_n[, .(chrno, .N, strand = "-"), by = start][N >= RCn][, .(chrno, start, N, strand)],
             paste0(out_dir, "negative_strand/","rc.prebed"),
             quote = FALSE, sep = "\t",
             col.names = FALSE,
             append = TRUE)
      rm(aln_pb_n)

      # extract negative strand SAfile of the chr
      if(nrow(aln_ns[(strand == "-")]) != 0){
        aln_ns_n <- aln_ns[(strand == "-"),.(start, cigar, seq)]
        # catch the number of soft-clipped nucleotides
        cigarn_n <- regexpr("^([1-9][0-9]|[3-9])S", aln_ns_n$cigar)
        Sstart_n <- 1
        Send_n <- attr(cigarn_n, "match.length")-1
        S_length_n <- as.numeric(substr(aln_ns_n$cigar, Sstart_n, Send_n))
        # split the seq to get the soft-clipped nucleotides
        aln_ns_n[, seq := substr(seq, 1, S_length_n)]
        # count the number and proportion of T
        aln_ns_n[, AL := sapply(base::strsplit(seq, ""), function(x) length(grep("T", x)))]
        aln_ns_n[, AP := as.numeric(AL/S_length_n)]
        # write down
        fwrite(aln_ns_n[AP >= 0.75, .(chrno, .N, strand = "-"), by=start][, .(chrno, start, N, strand)],
               paste0(out_dir, "negative_strand/", "sa.prebed"),
               quote = FALSE, sep = "\t",
               col.names = FALSE,
               append = TRUE)
        # clean
        rm(aln_ns_n)
        rm(S_length_n)
        rm(Sstart_n)
        rm(Send_n)
        gc()
      }
    }



    # positive strand
    if (nrow(aln_all[(strand == "+"),]) != 0) {
      # extract positive strand RCfile of the chr
      aln_pb_p <- aln_all[(strand == "+"), .(end)]
      fwrite(aln_pb_p[, .(chrno, .N, strand = "+"),by = end][N >= RCn][, .(chrno, end, N, strand)],
             paste0(out_dir, "positive_strand/", "rc.prebed"),
             quote = FALSE, sep = "\t",
             col.names = FALSE,
             append = TRUE)
      rm(aln_pb_p)

      # extract positive strand SAfile of the chr
      if(nrow(aln_ns[(strand == "+")]) != 0){
        aln_ns_p <- aln_ns[(strand == "+"), .(end, cigar, seq)]
        # catch the number of soft-clipped nucleotides
        cigarn_p <- regexpr("([1-9][0-9]|[3-9])S$", aln_ns_p$cigar)
        Sstart_p <- cigarn_p
        Send_p <- cigarn_p + attr(cigarn_p, "match.length")-2
        S_length_p <- as.numeric(substr(aln_ns_p$cigar, Sstart_p, Send_p))
        # split the seq to get the soft-clipped nucleotides
        aln_ns_p[, seq := substr(seq,seqlength - S_length_p + 1,seqlength)]
        # count the number and proportion of A
        aln_ns_p[, AL := sapply(base::strsplit(seq, ""),function(x) length(grep("A", x)))]
        aln_ns_p[, AP := as.numeric(AL/S_length_p)]
        # write down
        fwrite(aln_ns_p[AP >= 0.75, .(chrno, .N, strand = "+"), by = end][, .(chrno, end, N, strand)],
               paste0(out_dir, "positive_strand/", "sa.prebed"),
               quote = FALSE, sep = "\t",
               col.names = FALSE,
               append = TRUE)
        # clean
        rm(aln_ns_p)
        rm(S_length_p)
        rm(Sstart_p)
        rm(Send_p)
        gc()
      }
    }

    # clean
    rm(aln_all)
    rm(aln_ns)
    gc()
  }


  # write down cb_list
  print("write down cblist")
  cb_list_DT <- unique(rbindlist(cb_list))
  setkey(cb_list_DT, V1)
  setorder(cb_list_DT, V1)
  fwrite(cb_list_DT, paste0(out_dir, "_CBlist.txt"),
         quote = FALSE, sep = "\t", col.names = FALSE)
  print(paste0("outputs are in ",
               out_dir, "positive_strand/", " , ",
               out_dir, "negative_strand/", " and ",
               out_dir, "_CBlist.txt"))

}




